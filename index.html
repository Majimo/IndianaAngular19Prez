<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/ico" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/black.css" />
    <link rel="stylesheet" href="/node_modules/reveal.js/plugin/highlight/monokai.css" />
    <link rel="stylesheet" href="styles.css"></link>
    <title>Indiana Jones et le Temple Maudit d’Angular</title>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section>
                <div class="cv titre">
                    <div class="item">
                        <h1>Indiana Jones et le Temple Maudit d’Angular</h1>
                        <h2>1O ans d'Aventures et les Bonnes Pratiques en v19</h2>
                    </div>
                    <div class="item">
                        <p class="p-titre">Pierre FERVEL</p>
                        <p class="p-titre">BreizhCamp - 27 juin 2025</p>
                    </div>
                </div>
                <aside class="notes">
"Alors... est-ce qu’il y a des gens ici qui ont déjà mis les mains dans du AngularJS ?" </br>
(Pause dramatique, regarder les réactions) </br>
"Ok… j’espère que vous avez quitter ces projets depuis." </br>
"Aujourd’hui, on va retracer l’histoire d’Angular. Un framework qui a connu des hauts, des bas, des refontes, des révolutions... et qui est toujours là, solide comme un rocher qui déboule dans un tunnel — ou comme une dépendance dans ton package.json."
<p>Alors, enfilons notre chapeau d'archéologue du code, et partons à la découverte des trésors cachés d'Angular !</p>
                </aside>
            </section>
            
            <!-- Introduction -->
            <section>
                <section class="inner-section">
                    <h3>Angular, un framework front-end majeur depuis près de 10 ans</h3>
                    <aside class="notes">
"Angular, c’est plus qu’un simple framework. C’est une saga. 10 ans d’évolution, de paris techniques, de frustrations parfois… mais aussi de très belles idées." </br>
(regarde la salle) </br>
"Et si vous êtes ici, c’est peut-être parce que vous avez une app Angular en prod… que vous aimez ça… ou que vous êtes coincés avec."
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Obectifs de cette présentation</h3>
                    <ul>
                        <li>Les grandes étapes de l'évolution d'Angular</li>
                        <li>Les nouveautés clés et leur impact sur les applications modernes</li>
                        <li>Pleins de bonnes pratiques pour écrire du code Angular performant et maintenable</li>
                    </ul>
                    <aside class="notes">
"Mais ne vous inquiétez pas, je suis là pour vous aider à sortir de cette jungle !"
</br>
"L’objectif de ce talk ? Vous raconter cette histoire, mais surtout : </br>
Comprendre les grandes étapes,
Découvrir les nouveautés clés,
Et bien sûr, apprendre à écrire du code Angular qui soit à la fois performant et agréable à maintenir."
</br>
"Et je vous le dis tout de suite : ce sera une aventure nostalgique, technique mais passionnante, comme un bon vieux film d’Indiana Jones !"
                    </aside>
                </section>
            </section>

            <!-- Angular Evolution -->
            <!-- Les débuts d'Angular -->
            <section>
                <section class="inner-section">
                    <h3>Les débuts des frameworks front-end</h3>
                </section>
                <section class="inner-section">
                    <h3>jQuery et la jungle du web</h3>
                    <!-- Un peu de code jQuery là -->
                    <pre><code>
$(document).ready(function() {
    $('#myButton').click(function() {
        alert('Button clicked!');
    });
});
                    </code></pre>
                    <aside class="notes">
"Flashback. On est en 2010. Le front, c’est la jungle. 
Et là, arrive un super outil pour manipuler notre DOM : jQuery !
Alors bon... Très vite on bricole, on empile les scripts, on prie pour que le DOM nous obéisse.
Et ça se passe pas toujours comme on veut..."
                    </aside>
                </section>
                <section class="inner-section">
                    <h4>AngularJS, un framework révolutionnaire qui aura marqué une génération de développeurs</h4>
                    <!-- du code avec un hook angularjs -->
                    <pre><code>
angular.module('myApp', [])
    .controller('MyController', function($scope) {
        $scope.greeting = 'Hello, World!';
        $scope.updateGreeting = function(newGreeting) {
            $scope.greeting = newGreeting;
        };
    });
                    </code></pre>
                    <aside class="notes">
"C'est à ce moment qu'arrive AngularJS. C’est magique. Du double binding, des directives, une architecture MVC… c’est le feu !"
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Le passage difficile d'AngularJS à Angular 2</h3>
                    <div class="cv">
                        <div class="item">
                            <h4>Un reboot complet, plus brutal que le Crâne de Cristal pour plus de performance et de modularité</h4>
                            </br>
                            <p>Plus de $scope, désormais on utilise Typescript</p>
                            <pre><code data-line-numbers="1-3|4|8-10">import { Component } from '@angular/core';

@Component({
    selector: 'app-root',
    template: ``&lt;h1&gt;{{ greeting }}&lt;/h1&gt;``,
    styles: [`h1 { font-family: Lato; }`]
})
export class AppComponent {
    greeting = 'Hello, Angular 2!';
}
                            </code></pre>
                        </div>
                    </div>
                    <aside class="notes">
"Mais au bout de quelques années, c’est aussi un peu... la galère. Des scopes partout, du code spaghetti, difficile à maintenir. Le rêve tourne au cauchemar." </br>
"Et alors là, Google fait un truc radical : ils disent… ‘allez, on s'en fiche de tout ce qu'on a capitalisé, on recommence tout’."
(pause) </br>
"Angular 2, c’est pas une mise à jour. C’est un nouveau monde. Fini $scope, bonjour TypeScript. C’est plus rapide, plus propre, mais aussi… plus complexe."
</br>
"Un peu comme passer de Mario Kart à Dark Souls."
                    </aside>
                </section>
            </section>
            <!-- Angular 4 à 8 -->
            <section>
                <section class="inner-section">
                    <h3>Angular 4 à 8 : L'âge d'or</h3>
                    <div class="cv">
                        <div class="item">
                            <h4>Une stabilité maîtrisée qui entraîne des évolutions</h4>
                            <p>Améliorations des performances, meilleure gestion des dépendances</p>
                        </div>
                    </div>
                    <aside class="notes">
"Après ce reboot un peu violent, Angular trouve enfin son rythme." </br>
"Entre les versions 4 et 8, on a de la stabilité, des évolutions maîtrisées. On améliore le CLI, on simplifie la gestion des dépendances, on booste les perfs.
C’est l’époque où on commence à faire confiance au framework. On se dit : 'OK, c’est pas React, mais au moins ça bouge pas toutes les deux semaines.'" </br>
"Et en vrai, ça fait du bien."
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Les modules avec la directive @NgModule</h3>
                    <p>La directive permet d'importer les modules de manière plus ciblée, uniquement dans les modules qui en ont besoin.</p>
                    <pre><code data-line-numbers="1,5-10">import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LazyLoadedComponent } from './lazy-loaded.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [LazyLoadedComponent]
})
export class LazyLoadedModule { }
                    </code></pre>
                </section>
                <section class="inner-section">
                    <h3>Le lazy loading</h3>
                    <div class="cv">
                        <div class="item">
                            <pre><code data-line-numbers="3,5-10">// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { LazyLoadedModule } from './lazy-loaded/lazy-loaded.module';
const routes: Routes = [
    {
        path: 'lazy',
        loadChildren: () => import('./lazy-loaded/lazy-loaded.module').then(m => m.LazyLoadedModule)
    }
];
@NgModule({
    imports: [RouterModule.forRoot(routes)],
    exports: [RouterModule]
})
export class AppRoutingModule { }
                            </code></pre>
                        </div>
                        <div class="item">
                            <pre><code data-line-numbers="3,7">// app.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AppRoutingModule } from './app-routing.module';
@NgModule({
    imports: [
        CommonModule,
        AppRoutingModule
    ]
})
export class AppModule { }
                    </code></pre>
                </section>
                <section class="inner-section">
                    <h3>Les Observables</h3>
                    <pre><code data-line-numbers="2-3,15-24">import { Component } from '@angular/core';
import { Observable, of } from 'rxjs';
import { map } from 'rxjs/operators';
@Component({
    selector: 'app-observable-example',
    template: `
        &lt;div&gt;
            &lt;p&gt;Valeur : {{ value }}&lt;/p&gt;
            &lt;button (click)="fetchData()"&gt;Charger les données&lt;/button&gt;
        &lt;/div&gt;
    `
})
export class ObservableExampleComponent {
    value: string = 'Aucune donnée';
    fetchData() {
        this.getData().pipe(
            map(data => `Données récupérées : ${data}`)
        ).subscribe(result => {
            this.value = result;
        });
    }
    getData(): Observable&lt;string&gt; {
        return of('Données de l\'API');
    }
}
                   </code></pre>
                </section>
                <section class="inner-section">
                    <h3>De grandes évolutions dans la CLI d'Angular</h3>
                    <p>Angular 4</p>
                    <ul>
                        <li>Possibilité de créer des guards, des resolvers, des composants plus spécifiques</li>
                    </ul>
                    <p>Angular 5</p>
                    <ul>
                        <li>Introduction du support des PWA (Progressive Web App)</li>
                    </ul>
                    <p>Angular 6</p>
                    <ul>
                        <li>Gestion de l'ajout de dépendances npm</li>
                        <li>Possibilité de réaliser des tests unitaires</li>
                    </ul>
                    <p>Angular 7</p>
                    <ul>
                        <li>Mise à jour globale des dépendances (`ng update`)</li>
                    </ul>
                    <aside class="notes">
Une PWA (Progressive Web App) est un type d'application web qui combine les avantages des applications web traditionnelles et des applications mobiles natives.
</br>
Voici les principales caractéristiques d'une PWA :
</br>
Accessibilité : Une PWA est accessible via un simple lien web, sans avoir besoin d'être installée sur l'appareil de l'utilisateur. </br>
Expérience utilisateur améliorée : Une PWA offre une expérience utilisateur fluide et rapide, similaire à celle d'une application mobile native. </br>
Hors-ligne : Une PWA peut fonctionner hors-ligne, grâce à l'utilisation de "service workers" qui mettent en cache les ressources nécessaires. </br>
Notifications push : Une PWA peut envoyer des notifications push à l'utilisateur, comme une application mobile. </br>
Ajout à l'écran d'accueil : L'utilisateur peut ajouter une PWA à l'écran d'accueil de son appareil, comme une application mobile. </br>
Mise à jour automatique : Une PWA se met à jour automatiquement, sans nécessiter d'intervention de l'utilisateur. </br>
Sécurité : Une PWA est servie en HTTPS, ce qui assure la sécurité des données. </br>
L'introduction du support des PWA dans Angular 5 a permis aux développeurs de créer facilement des applications web progressives, en bénéficiant de toutes ces fonctionnalités. -->                        
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Angular Material</h3>
                    <p>Officialisation d'Angular Material basé sur les versions d'Angular</p>
                    <img src="./assets/material_v5.png" alt="Angular Material" style="height:700px;width:auto" />
                    <aside class="notes">
"Et bien sûr, y’a Angular Material. Pour vulgariser, c'est un peu comme le petit frère de Bootstrap, mais pour Angular.
C’est beau, c’est propre, et ça te fait gagner un temps fou." </br>
"Mais attention, c’est pas juste du CSS. C’est une vraie bibliothèque de composants qui respecte les principes du Material Design." </br>
"Et ça, c’est pas rien !"
</br>
Bon, en réalité, il existait déjà en développement dans la version 2, mais la version 4 a marqué une étape importante dans son évolution et son adoption par la communauté Angular.
// Donc pour résumer, Angular Material a bien été introduit dès la version 2 d'Angular, mais la version 4 a représenté une étape clé dans son développement et son adoption.
                    </aside>
                </section>
            </section>
            <!-- Angular 9 à 12 -->
            <section>
                <section class="inner-section">
                    <h3>Angular 9 à 12 : L'ère Ivy</h3>
                    <aside class="notes">
                        "C'est à partir de là qu'on se dit : 'OK, on a un framework qui commence à sacrément ressembler à qqchose.'"
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Ivy, un moteur de rendu révolutionnaire</h3>
                    <p>Optimisation des performances et de la taille des bundles</p>
                    <aside class="notes">
"Et bam avec Angular 9, Ivy arrive pour remplacer l'AOT (Ahead of Time)."
</br>
"C’est un nouveau moteur de rendu. Mais attention, ça change tout… sans rien casser.
Concrètement, Ivy rend le framework plus rapide (tree-shaking), plus léger, plus flexible. Tu peux compiler juste ce dont t’as besoin. Et ça ouvre la porte à des features plus modernes derrière." </br>
"Sur certains projets, on a vu des bundles réduire de 30 à 40%, juste avec Ivy."
<!--
Amélioration de la gestion des erreurs => messages d'erreur plus clairs et plus précis notamment lors du préchargement
-->
                    </aside>
                </section>
                <section class="inner-section">
                    <h3>Suivi des évolutions de TypeScript (3.7 -> 4.2)</h3>
                </section>
            </section>
            <!-- Angular 13 à 19 -->
            <section>
                <section class="inner-section">
                    <h3>Angular 13 à 19 : Retour vers le futur des frameworks front-end</h3>
                </section>
                <section class="inner-section">
                    <h3>Flexibilité, modularité et performance</h3>
                    <p>Standalone Components, Federated Modules et Standalone Directives</p>
                    <aside class="notes">
"Angular continue d'évoluer. On entre dans une nouvelle ère, l'ère moderne." </br>
"Fini les NgModules ? Presque." </br>
"Aujourd’hui, on peut créer un composant Angular sans avoir à déclarer un module. C’est plus simple, plus clair, plus rapide. Bon, dans la pratique; comme on va le voir, ça permet surtout d'alléger l'architecture de l'application et de la rendre plus maintenable." </br>
                   </aside>
                </section>
                <section class="inner-section">
                    <pre><code data-line-numbers="4-7|8-17|18-25|27">
my-app/
├── src/
│   ├── app/
│   │   ├── app.component.ts
│   │   ├── app.module.ts
│   │   └── app-routing.module.ts
│   ├── products/
│   │   ├── pipes/
│   │   │   ├── cart-product.pipe.ts
│   │   ├── components/
│   │   │   ├── product.component.ts
│   │   │   └── cart.component.ts
│   │   ├── services/
│   │   │   └── product.service.ts
│   │   ├── products.module.ts
│   │   └── products-routing.module.ts
│   ├── orders/
│   │   ├── components/
│   │   │   ├── order-form.component.ts
│   │   │   └── order-confirmation.component.ts
│   │   ├── services/
│   │   │   └── order.service.ts
│   │   ├── orders.module.ts
│   │   └── orders-routing.module.ts
│   └── main.ts
├── webpack.config.js
└── package.json
                    </code></pre>
                    <aside class="notes">
1 - Application principale (app/) : </br>
Contient le composant racine, le module principal et le routage de l'application. </br>
Utilise le "Module Federation Plugin" pour charger dynamiquement les modules fédérés. </br>
2 - Module de Produits (products/) : </br>
Contient les composants et services liés à la gestion des produits. </br>
Les composants sont définis comme des Standalone Components. </br>
Le module et le routage sont encapsulés dans ce dossier. </br>
3 - Module de Commandes (orders/) : </br>
Contient les composants et services liés à la gestion des commandes. </br>
Les composants sont également définis comme des Standalone Components. </br>
Le module et le routage sont encapsulés dans ce dossier. </br>
4 - Configuration Webpack (webpack.config.js) : </br>
Contient la configuration du "Module Federation Plugin" pour permettre le chargement dynamique des modules fédérés.  
                    </aside>
                </section>
                <section class="inner-section">
                    <div class="item">
                        <ul>
                            <li>Amélioration de la gestion des formulaires (TypedForms) v13</li>
                            <li>Signals v16</li>
                            <li>defer() v16</li>
                        </ul>
                    </div>
                    <aside class="notes">
"Et puis débarque le principe des Signals. Une nouvelle manière de gérer la réactivité, inspirée du monde de la programmation réactive… mais plus lisible, plus intuitive.
Pour les quelques fans de React qui ont eu le courage de venir à cette conf, vous n'êtes pas perdu avec ces principes (en même temps, on vient de parler de meilleure réactivité). C’est un peu comme si Angular avait décidé de prendre un café avec React." </br>
"Il y’a ayssi defer(). C’est un peu comme un 'setTimeout' pour tes appels API mais toujours pareil, dans un principe de meilleure gestion de la réactivité. 
Tu peux dire à Angular : 'Hé, attends un peu avant de charger ça.' Et Angular te dit : 'Pas de souci, je vais attendre, tu m'préviens et je lance ton appel quand t'es ok.'" </br>
"Vous allez me dire, 'Ben ils sont où les exemples ?!' Pas d'inquiétudes, je vous détaille tout ça dans qq minutes dans les bonnes pratiques"
                    </aside>
                </section>
            </section>

            <!-- Bonnes pratiques -->
            <section>
                <section class="inner-section">
                    <h3>Les bonnes pratiques actuelles pour donner un bon coup de fouet à vos applications</h3>
                </section>
                <!-- Structural Control Flow (Angular 14) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Structural Control Flow Syntax</h3>
                            <pre><code class="language-typescript" data-line-numbers="1-5|7-9|11-13">@if (user.isLoggedIn) {
    &lt;p&gt;Bienvenue, {{ user.name }} !&lt;/p&gt;
} @else {
    &lt;p&gt;Veuillez vous connecter.&lt;/p&gt;
}

@for (let item of items; track item.id) {
    &lt;li&gt;{{ item.name }}&lt;/li&gt;
}

@let currentDate = today() {
    &lt;p&gt;Nous sommes le {{ currentDate }}&lt;/p&gt;
}
                            </code></pre>
                        </div>
                    </div>
                </section>
                <!-- Standalone Components (Angular 14) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Standalone Components</h3>
                            <pre><code class="language-typescript" data-line-numbers="5-10">import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';

@Component({
    selector: 'app-standalone',
    template: '&lt;h1&gt;Standalone Component&lt;/h1&gt;'
    standalone: true,
    imports: [CommonModule, RouterModule]
})
export class StandaloneComponent {
    constructor() {
        console.log('Standalone Component Initialized');
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
                <!-- Typed Forms (Angular 14) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Typed Forms</h3>
                            <pre><code class="language-typescript" data-line-numbers="4-8|14|17-21,26-27">import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';

interface User {
    name: string;
    email: string;
    age: number;
}

@Component({
    selector: 'app-user-form',
})
export class UserFormComponent {
    userForm: FormGroup;

    constructor(private fb: FormBuilder) {
        this.userForm = this.fb.group({
            name: ['', Validators.required],
            email: ['', [Validators.required, Validators.email]],
            age: [null, [Validators.required, Validators.min(0)]],
        }) as FormGroup&lt;User&gt;;
    }

    onSubmit() {
        if (this.userForm.valid) {
            const userData: User = this.userForm.value;
            console.log(userData);
        }
    }
}                                
                            </code></pre>
                        </div>
                    </div>
                </section>
                <!-- Dependency Injection -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Dependency Injection</h3>
                            <pre><code class="language-typescript" data-line-numbers="1,4-6,13,15,22">//monservice.service.ts
import { Injectable } from '@angular/core';

@Injectable({
    providedIn: 'root'
})
export class MyService {
    getData() {
        return 'Hello from MyService';
    }
}

// moncomposant.component.ts
import { Component } from '@angular/core';
import { MyService } from './monservice.service';

@Component({
    selector: 'app-dependency-injection',
    template: '&lt;p&gt;{{ data }}&lt;/p&gt;'
})
export class DependencyInjectionComponent {
    @Inject(MyService) myService: MyService;

    data = this.myService.getData();
}
                            </code></pre>
                        </div>
                    </div>
                </section>
                <!-- Signals (Angular 16) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Signals</h3>
                            <pre><code class="language-typescript" data-line-numbers="6-7,11-14">import { Component, signal } from '@angular/core';

@Component({
    selector: 'app-signals',
    template: `
        &lt;p&gt;Count: {{ count() }}&lt;/p&gt;
        &lt;button (click)="increment()"&gt;Increment&lt;/button&gt;
    `
})
export class SignalsComponent {
    count = signal(0);
    increment() {
        this.count.update(value => value + 1);
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
                <!-- Signals with linkedSignal (l'effet est répercuté directement depuis le signal Angular v20) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>Shared Linked Signals</h3>
                            <div class="ch">
                                <div class="item">
                                    <pre><code class="language-typescript">// user.state.ts
import { signal } from '@angular/core';

export const userAuthSignal = signal({ isAuthenticated: false, user: null });

export function login(user: any) {
    userAuthSignal.set({ isAuthenticated: true, user });
}

export function logout() {
    userAuthSignal.set({ isAuthenticated: false, user: null });
}
                                    </code></pre>
                                </div>
                                <div class="item">
                                    <pre><code class="language-typescript" data-line-numbers="2,13,19,22,26">// app.component.ts
import { userAuthSignal, logout } from '@state/user.state';

@Component({
    selector: 'app-linked-signals',
    template: `
    <nav>
        @if (userAuthSignal().isAuthenticated) {
            <span>Welcome, {{ userAuthSignal().user.name }}!</span>
            <button (click)="handleLogout()">Logout</button>
        } @else {
            <span>Please log in.</span>
            <button (click)="handleLogin({ name: 'John Doe' })">Login</button>
        }
    </nav>
    `,
})
export class LinkedSignalsComponent {
    userAuthSignal = userAuthSignal;

    handleLogout() {
        logout();
    }

    handleLogin(user: any) {
        login(user);
    }
}
                                    </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!-- defer() (Angular 16) -->
                <section class="inner-section">
                    <div class="cv">
                        <div class="item">
                            <h3>defer()</h3>
                            <div class="ch">
                                <div class="item">
                                    <pre><code class="language-typescript" data-line-numbers="10-12">// data.service.ts
import { Injectable } from '@angular/core';
import { of } from 'rxjs';
import { delay } from 'rxjs/operators';

@Injectable({
    providedIn: 'root',
})
export class DataService {
    fetchData() {
        return of('Données récupérées !').pipe(delay(2000));
    }
}       
                                    </code></pre>
                                </div>
                                <div class="item">
                                    <pre><code class="language-typescript" data-line-numbers="3,9-12,21-23">// data-fetcher.component.ts
import { Component } from '@angular/core';
import { defer } from 'rxjs';
import { DataService } from './data.service';

@Component({
    selector: 'app-data-fetcher',
    template: `
    <button (click)="loadData()">Charger les données</button>
    @if (data) {
        <p>Données : {{ data }}</p>
    }
    `,
})
export class DataFetcherComponent {
    data: string | null = null;

    constructor(private dataService: DataService) {}

    loadData() {
        defer(() => this.dataService.fetchData()).subscribe((result) => {
            this.data = result;
        });
    }
}
                                    </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
L'avantage de defer() est qu'il permet de retarder l'exécution d'une opération jusqu'à ce qu'elle soit réellement nécessaire. Cela peut être utile pour optimiser les performances de votre application Angular, en évitant d'exécuter des opérations inutiles.
Il est important de noter que defer() ne remplace pas setTimeout(), mais il offre une alternative plus puissante et flexible pour gérer l'asynchronisme dans Angular.
La principale différence réside dans la façon dont ils gèrent l'exécution asynchrone. </br>
- Différence de comportement:
setTimeout() planifie l'exécution d'une fonction après un délai spécifié, mais cette fonction est exécutée dans le contexte de l'événement principal (le thread principal).
defer() crée une nouvelle Observable qui sera exécutée de manière différée, c'est-à-dire que l'exécution sera retardée jusqu'à ce que la Observable soit souscrite. </br>
- Différence de gestion des erreurs:
Avec setTimeout(), les erreurs éventuelles sont propagées dans le flux d'exécution principal, ce qui peut entraîner des problèmes dans votre application.
Avec defer(), les erreurs sont gérées dans le contexte de l'Observable, ce qui permet une meilleure gestion des erreurs et une séparation des préoccupations. </br>
- Différence de composition:
setTimeout() est une fonction native de JavaScript, tandis que defer() fait partie de la bibliothèque RxJS, ce qui permet une meilleure intégration avec les opérateurs RxJS et une meilleure composabilité. </br>
En résumé, defer() offre une meilleure gestion de l'asynchronisme, une meilleure gestion des erreurs et une meilleure intégration avec les concepts réactifs d'Angular, par rapport à l'utilisation de setTimeout() seul.
                    </aside>
                </section>
            </section>

            <!-- Conclusion -->
            <section>
                <section class="inner-section">
                    <h3>Conclusion</h3>
                    <p>Quel avenir pour le framework ?</p> 
                    
                    <aside class="notes">
                        <p>Angular a parcouru un long chemin depuis ses débuts, et il continue d'évoluer pour répondre aux besoins des développeurs modernes.</p>
                        <p>Une écoute concrète et permanente de la communauté</p>
                        <p>zone.js bientôt abandonné</p>
                        <p>des structures plus légères et plus réactives avec les signaux et les standalones components</p>
                        <p>un rapprochement toujours plus concret de ReactJs</p>
                        <br />
                        <p>Et pour ceux qui se le demandent Angular est toujours là, solide comme un rocher, prêt à dévaler de nouveaux tunnels.</p>
                        <p>Alors, que vous soyez un développeur Angular chevronné ou un novice curieux et même si le chemin peut être semé d'embûches, chaque ligne de code que vous écrivez est une étape de plus dans cette aventure passionnante qu'est Angular.</p>
                        <p>Merci de votre attention !</p>
                    </aside>
                </section>
            </section>
        </div><!-- slides -->
    </div><!-- reveal -->

    <!-- Scripts -->
    <script type="module" src="./main.js"></script>
</body>

</html>